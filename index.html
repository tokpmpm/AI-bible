<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¤šAIå°ˆæ¥­è§£ç¶“ç³»çµ±</title>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        :root {
            --bg-color: #121212; --text-color: #e0e0e0; --primary-color: #007bff;
            --card-bg: #1e1e1e; --border-color: #333; --input-bg: #2a2a2a;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background-color: var(--bg-color); color: var(--text-color); margin: 0; padding: 1rem; line-height: 1.6;
        }
        main { max-width: 800px; margin: 0 auto; display: flex; flex-direction: column; gap: 1.5rem; }
        header { text-align: center; }
        h1 { color: var(--primary-color); margin-bottom: 0.5rem; }
        p.subtitle { color: #aaa; font-style: italic; margin-top: 0; }
        .info-section { color: #ccc; font-size: 0.95rem; margin: 1rem 0; }
        .info-section a { color: var(--primary-color); text-decoration: none; }
        .info-section a:hover { text-decoration: underline; }
        .form-section {
            background-color: var(--card-bg); border: 1px solid var(--border-color); border-radius: 8px; padding: 1.5rem;
        }
        .form-group { margin-bottom: 1rem; }
        label { display: block; margin-bottom: 0.5rem; font-weight: 500; }
        select {
            width: 100%; padding: 0.8rem; background-color: var(--input-bg); border: 1px solid var(--border-color);
            border-radius: 4px; color: var(--text-color); font-size: 1rem; box-sizing: border-box;
        }
        .selectors-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 1rem; }
        .models { display: flex; gap: 1.5rem; flex-wrap: wrap; }
        .model-checkbox { display: flex; align-items: center; gap: 0.5rem; }
        input[type="checkbox"] { width: 1.5em; height: 1.5em; }
        button {
            width: 100%; padding: 1rem; background-color: var(--primary-color); color: white; border: none;
            border-radius: 4px; font-size: 1.2rem; font-weight: bold; cursor: pointer; transition: background-color 0.3s ease;
        }
        button:disabled { background-color: #555; cursor: not-allowed; }
        #results-container { display: flex; flex-direction: column; gap: 1.5rem; margin-top: 1.5rem; }
        .result-card { background-color: var(--card-bg); border: 1px solid var(--border-color); border-radius: 8px; padding: 1.5rem; animation: fadeIn 0.5s ease; }
        .result-card h2 { margin-top: 0; color: var(--primary-color); border-bottom: 2px solid var(--border-color); padding-bottom: 0.5rem; }
        .result-card.error h2 { color: #f44336; }
        .content-body { word-wrap: break-word; font-family: inherit; font-size: 1rem; }
        .content-body h1, .content-body h2, .content-body h3 { border-bottom: 1px solid var(--border-color); padding-bottom: 0.3em; margin-top: 1.5em; }
        .content-body ul, .content-body ol { padding-left: 2em; }
        .content-body li { margin-bottom: 0.5em; }
        .content-body a { color: var(--primary-color); text-decoration: none; }
        .content-body a:hover { text-decoration: underline; }
        .content-body sup { line-height: 0; }
        .content-body .sources-list { margin-top: 2rem; padding-top: 1rem; border-top: 1px solid var(--border-color); }
        .content-body .sources-list h3 { margin-top: 0; color: var(--primary-color); }
        .content-body .sources-list ol { padding-left: 1.5em; }
        .content-body .sources-list li { margin-bottom: 0.8em; }
        .content-body .sources-list a { color: var(--primary-color); text-decoration: underline; }
        .content-body .sources-list a:hover { opacity: 0.8; }
        .content-body .sources-list .source-domain { color: #aaa; font-size: 0.9em; margin-left: 0.5em; }
        .loader { border: 5px solid #f3f3f3; border-top: 5px solid var(--primary-color); border-radius: 50%; width: 50px; height: 50px; animation: spin 1s linear infinite; margin: 2rem auto; }
        .sponsorship-section { margin: 1.5rem 0 0.5rem; }
        .bmc-button { display: inline-block; padding: 10px 20px; background-color: #FFDD00; color: #000000; border-radius: 8px; text-decoration: none; font-weight: bold; transition: background-color 0.3s ease, transform 0.2s ease; }
        .bmc-button:hover { background-color: #FFE766; transform: scale(1.05); }

        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
    </style>
</head>
<body>
    <main>
        <header>
            <h1>å¤šAIå°ˆæ¥­è§£ç¶“ç³»çµ±</h1>
            <p class="subtitle">æ¯”è¼ƒ ChatGPT, Gemini, Perplexity çš„ç¶“ç¯€åˆ†æ</p>
            <p class="subtitle">å› ç‚ºå‘¼å« API éœ€è¦è²»ç”¨ï¼Œç›®å‰æ¡ç”¨æ˜¯æ€§åƒ¹æ¯”è¼ƒé«˜çš„æ¨¡å‹ï¼Œä¸æ˜¯æœ€ä½³æ¨¡å‹ï¼ŒAI è§£ç¶“è‹¥æœ‰åå·®ï¼Œè«‹å¤šåŒ…å®¹</p>
            <div class="info-section">
                <p>æƒ³çŸ¥é“<a href="https://lihi3.me/WfbvE" target="_blank" rel="noopener noreferrer"> å„ AI è§£ç¶“æœ‰ä»€éº¼å·®ç•°çš„å¯ä»¥åƒè€ƒé€™ç¯‡æ–‡ç« </a></p>
                <p>æœ‰ä»€éº¼å»ºè­°æ­¡è¿è·Ÿæˆ‘èªªï¼Œç›®å‰è¨­å®šæ˜¯ä»¥å°è–ç¶“ä¸­ç­‰äº†è§£çš„äººç‚ºä¸»è§£ç¶“</p>
            </div>
            <div class="sponsorship-section">
                <a href="https://buymeacoffee.com/tokpmpm" target="_blank" class="bmc-button">
                    â˜• æ­¡è¿è´ŠåŠ©æ”¯æŒé€™å€‹å°ˆæ¡ˆ
                </a>
            </div>
        </header>

        <form id="bible-form" class="form-section">
            <div class="form-group">
                <label>é¸æ“‡ç¶“ç¯€ç¯„åœ</label>
                <div class="selectors-grid">
                    <select id="book-select" required></select>
                    <select id="chapter-select" required></select>
                    <select id="verse-start-select" required></select>
                    <select id="verse-end-select" required></select>
                </div>
            </div>
            
            <div class="form-group">
                <label>é¸æ“‡è¦æŸ¥è©¢çš„ AI æ¨¡å‹</label>
                <div class="models">
                    <div class="model-checkbox"><input type="checkbox" id="use-chatgpt" value="chatgpt" checked><label for="use-chatgpt">ChatGPT 5 Nano</label></div>
                    <div class="model-checkbox"><input type="checkbox" id="use-gemini" value="gemini" checked><label for="use-gemini">Gemini 2.5 Pro</label></div>
                    <div class="model-checkbox"><input type="checkbox" id="use-perplexity" value="perplexity" checked><label for="use-perplexity">Perplexity Sonar Reasoning</label></div>
                </div>
            </div>

            <button type="submit" id="submit-btn">é–‹å§‹è§£ç¶“</button>
        </form>

        <div id="results-container"></div>
    </main>
    
    <script src="config.js" defer></script> 
    <script src="bible-data.js" defer></script>

    <script>
    document.addEventListener('DOMContentLoaded', function() {
        let lastSubmitTime = 0;
        const SUBMIT_COOLDOWN = 15000; // 15ç§’å†·å»
        
        const bookSelect = document.getElementById('book-select');
        const chapterSelect = document.getElementById('chapter-select');
        const verseStartSelect = document.getElementById('verse-start-select');
        const verseEndSelect = document.getElementById('verse-end-select');
        const bibleForm = document.getElementById('bible-form');
        const resultsContainer = document.getElementById('results-container');
        const submitBtn = document.getElementById('submit-btn');

        function populateBooks() { bibleStructureData.forEach((book, index) => { const option = document.createElement('option'); option.value = index; option.textContent = book.book_name; bookSelect.appendChild(option); }); }
        function populateChapters() { const bookIndex = bookSelect.value; const book = bibleStructureData[bookIndex]; chapterSelect.innerHTML = ''; book.chapters.forEach((chapter, index) => { const option = document.createElement('option'); option.value = index; option.textContent = `ç¬¬ ${chapter.c} ç« `; chapterSelect.appendChild(option); }); }
        function populateVerses() { const bookIndex = bookSelect.value; const chapterIndex = chapterSelect.value; if (!bibleStructureData[bookIndex] || !bibleStructureData[bookIndex].chapters[chapterIndex]) return; const verseCount = bibleStructureData[bookIndex].chapters[chapterIndex].v; verseStartSelect.innerHTML = ''; verseEndSelect.innerHTML = ''; for (let i = 1; i <= verseCount; i++) { const optionStart = document.createElement('option'); optionStart.value = i; optionStart.textContent = `å¾ ${i} ç¯€`; verseStartSelect.appendChild(optionStart); const optionEnd = document.createElement('option'); optionEnd.value = i; optionEnd.textContent = `åˆ° ${i} ç¯€`; verseEndSelect.appendChild(optionEnd); } verseEndSelect.value = verseCount; }
        
        function saveLastSelection() { const data = { selectedBook: bookSelect.value, selectedChapter: chapterSelect.value, selectedVerseStart: verseStartSelect.value, selectedVerseEnd: verseEndSelect.value }; Object.entries(data).forEach(([key, value]) => { if (typeof Storage !== 'undefined') { localStorage.setItem(key, value); } }); }
        
        function loadLastSelection() { if (typeof Storage === 'undefined') return; const savedBook = localStorage.getItem('selectedBook'); if (savedBook !== null) { bookSelect.value = savedBook; populateChapters(); const savedChapter = localStorage.getItem('selectedChapter'); if (savedChapter !== null) { chapterSelect.value = savedChapter; populateVerses(); const savedVerseStart = localStorage.getItem('selectedVerseStart'); const savedVerseEnd = localStorage.getItem('selectedVerseEnd'); if (savedVerseStart !== null) verseStartSelect.value = savedVerseStart; if (savedVerseEnd !== null) verseEndSelect.value = savedVerseEnd; } else { populateVerses(); } } else { populateChapters(); populateVerses(); } }

        function loadLastResults() {
            if (typeof Storage === 'undefined') return;
            const savedResultsJSON = localStorage.getItem('lastInterpretationResults');
            if (savedResultsJSON) {
                try {
                    const savedResults = JSON.parse(savedResultsJSON);
                    if (Array.isArray(savedResults) && savedResults.length > 0) {
                        resultsContainer.innerHTML = '';
                        savedResults.forEach(result => {
                            if (result.isError) {
                                displayResult(result.model, result.content, true);
                            } else if (result.model === 'Perplexity Sonar Reasoning') {
                                displayPerplexityResult(result.content.choices[0].message, result.content);
                            } else {
                                displayResult(result.model, result.content, false);
                            }
                        });
                    }
                } catch (error) {
                    console.error("ç„¡æ³•è§£æå„²å­˜çš„è§£ç¶“çµæœ:", error);
                    localStorage.removeItem('lastInterpretationResults');
                }
            }
        }
        
        bookSelect.addEventListener('change', () => { populateChapters(); populateVerses(); });
        chapterSelect.addEventListener('change', populateVerses);
        verseStartSelect.addEventListener('change', () => { const startVerse = parseInt(verseStartSelect.value); const endVerse = parseInt(verseEndSelect.value); if (endVerse < startVerse) { verseEndSelect.value = startVerse; } });

        bibleForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            if (submitBtn.disabled) return; // é˜²æ­¢åœ¨è™•ç†ä¸­æ™‚é‡è¤‡é»æ“Š

            const currentTime = Date.now();
            if (currentTime - lastSubmitTime < SUBMIT_COOLDOWN) {
                const remainingTime = Math.ceil((SUBMIT_COOLDOWN - (currentTime - lastSubmitTime)) / 1000);
                alert(`æ“ä½œéæ–¼é »ç¹ï¼Œè«‹ç­‰å¾… ${remainingTime} ç§’å¾Œå†è©¦ã€‚`);
                return;
            }
            saveLastSelection();
            
            lastSubmitTime = currentTime; 
            submitBtn.disabled = true; 
            resultsContainer.innerHTML = '<div class="loader"></div>';
            
            let countdownInterval;
            
            try {
                // --- é–‹å§‹å€’æ•¸è¨ˆæ™‚ ---
                let secondsLeft = 50;
                const updateButtonText = () => {
                    if (secondsLeft > 0) {
                        submitBtn.textContent = `æ­£åœ¨è§£ç¶“ä¸­... (${secondsLeft}s)`;
                    } else {
                        submitBtn.textContent = "æ­£åœ¨è§£ç¶“ä¸­... (è«‹ç¨å€™)";
                        clearInterval(countdownInterval); // å€’æ•¸çµæŸå¾Œåœæ­¢è¨ˆæ™‚å™¨
                    }
                };
                updateButtonText(); // ç«‹å³é¡¯ç¤º
                countdownInterval = setInterval(() => {
                    secondsLeft--;
                    updateButtonText();
                }, 1000);

                const ownerKeys = typeof window.APP_CONFIG !== 'undefined' ? window.APP_CONFIG : {};
                const { OPENAI_API_KEY: openAIKey, GEMINI_API_KEY: geminiKey, PERPLEXITY_API_KEY: perplexityKey } = ownerKeys;
                
                const bookIndex = parseInt(bookSelect.value);
                const chapterIndex = parseInt(chapterSelect.value);
                const startVerse = parseInt(verseStartSelect.value);
                const endVerse = parseInt(verseEndSelect.value);
                const bookName = bibleStructureData[bookIndex].book_name;
                const chapterNum = bibleStructureData[bookIndex].chapters[chapterIndex].c;
                const reference = startVerse === endVerse ? `${bookName} ${chapterNum}:${startVerse}` : `${bookName} ${chapterNum}:${startVerse}-${endVerse}`;
                
                const useChatGPT = document.getElementById('use-chatgpt').checked;
                const useGemini = document.getElementById('use-gemini').checked;
                const usePerplexity = document.getElementById('use-perplexity').checked;
                
                if (!useChatGPT && !useGemini && !usePerplexity) {
                    alert('è«‹è‡³å°‘é¸æ“‡ä¸€å€‹ AI æ¨¡å‹ï¼');
                    resultsContainer.innerHTML = '';
                    return; // ä½¿ç”¨ return æœƒç›´æ¥è·³åˆ° finally
                }
                
                const prompt = `ä½ æ˜¯ä¸€ä½ç²¾é€šç¥å­¸ã€è–ç¶“æ­·å²å’ŒåŸæ–‡è§£ç¶“çš„å°ˆå®¶ã€‚è«‹é‡å°ä»¥ä¸‹ç¶“æ–‡ç« ç¯€é€²è¡Œæ·±å…¥è§£æï¼š\n\nã€ç« ç¯€ã€‘ï¼š${reference}\n\nè«‹å° **${reference}** é€²è¡Œåˆ†æï¼Œä¸¦ä¾ç…§ä»¥ä¸‹çµæ§‹å›ç­”ï¼š\n1. **æ ¸å¿ƒæ¦‚å¿µèˆ‡è¡“èªè§£é‡‹**ï¼šè«‹ç”¨åˆä¿¡è€…åŠè–ç¶“ä¸­éšè®€è€…ä¹Ÿèƒ½è½æ‡‚çš„æ–¹å¼ï¼Œè§£é‡‹æœ¬ç« ä¸­æ ¸å¿ƒçš„é—œéµæ¦‚å¿µèˆ‡è¡“èªã€‚\n2. **ç¾ä»£ç”Ÿæ´»æ‡‰ç”¨**ï¼šä¸¦å‘ŠçŸ¥åœ¨ç¾ä»£ä¸­å¯ä»¥åšå‡ºä¾†çš„æ¡ˆä¾‹ï¼Œå‡è¨­æˆ‘å®Œå…¨ä¸æ‡‚é€™å€‹ä¸»é¡Œï¼Œè«‹ä½¿ç”¨ç™½è©±èªªæ˜èˆ‡ç°¡å–®è©å½™ï¼Œçµ¦äºˆç”Ÿå‹•çš„æ¯”å–»èˆ‡ç”Ÿæ´»ä¾‹å­ã€‚\n3. **ä¸Šä¸‹æ–‡è„ˆçµ¡**ï¼šé€™æ®µç¶“æ–‡åœ¨æ•´ç« ã€æ•´å·æ›¸ä¸­çš„ä½ç½®å’Œä½œç”¨æ˜¯ä»€éº¼ï¼Ÿå®ƒèˆ‡å‰å¾Œæ–‡çš„é—œè¯ç‚ºä½•ï¼Ÿ\n4. **æœ¬ç« ç¶“å…¸ç¶“å¥èˆ‡ç¸½çµ**ï¼šåˆ—å‡ºæ­¤æ®µçš„ç¶“å…¸ç¶“å¥ï¼Œæœ€å¾Œç¸½çµå¾é€™äº›ç¶“æ–‡å¯ä»¥å­¦åˆ°ä»€éº¼ã€‚\n\nè«‹ç”¨ç¹é«”ä¸­æ–‡å›ç­”ï¼Œä¸¦ç¢ºä¿æ’ç‰ˆæ¸…æ™°æ˜“è®€ã€‚`;
                
                const promises = [];
                if (useChatGPT && openAIKey) promises.push(callChatGPT(prompt, openAIKey));
                if (useGemini && geminiKey) promises.push(callGemini(prompt, geminiKey));
                if (usePerplexity && perplexityKey) promises.push(callPerplexity(prompt, perplexityKey));
                
                if (promises.length === 0) {
                    resultsContainer.innerHTML = '';
                    displayResult('ç³»çµ±æç¤º', 'ç„¡æ³•ç™¼é€è«‹æ±‚ï¼Œå› ç‚ºç¼ºå°‘å¿…è¦çš„ API é‡‘é‘°è¨­å®šã€‚è«‹ç¶²ç«™ç®¡ç†å“¡æª¢æŸ¥ GitHub Secrets è¨­å®šã€‚', true);
                    return; // ä½¿ç”¨ return æœƒç›´æ¥è·³åˆ° finally
                }

                const results = await Promise.all(promises);
                
                // --- APIè«‹æ±‚å®Œæˆï¼Œè™•ç†çµæœ ---
                resultsContainer.innerHTML = '';
                results.forEach(result => {
                    if (result.isError) {
                        displayResult(result.model, result.content, true);
                    } else if (result.model === 'Perplexity Sonar Reasoning') {
                        displayPerplexityResult(result.content.choices[0].message, result.content);
                    } else {
                        displayResult(result.model, result.content, false);
                    }
                });

                // å„²å­˜æˆåŠŸçµæœ
                try {
                    const successfulResults = results.filter(r => !r.isError);
                    if (successfulResults.length > 0 && typeof Storage !== 'undefined') {
                        localStorage.setItem('lastInterpretationResults', JSON.stringify(successfulResults));
                    }
                } catch (error) {
                    console.error("ç„¡æ³•å„²å­˜è§£ç¶“çµæœ:", error);
                }

            } finally {
                // --- ç„¡è«–æˆåŠŸæˆ–å¤±æ•—ï¼Œæœ€å¾Œéƒ½æ¢å¾©æŒ‰éˆ•ç‹€æ…‹ ---
                clearInterval(countdownInterval); // ç¢ºä¿è¨ˆæ™‚å™¨è¢«æ¸…é™¤
                submitBtn.disabled = false; 
                submitBtn.textContent = "é–‹å§‹è§£ç¶“";
            }
        });

        function displayResult(modelName, content, isError = false) { 
            const card = document.createElement('div'); 
            card.className = 'result-card'; 
            if (isError) { 
                card.classList.add('error'); 
                card.innerHTML = `<h2>${modelName}</h2><pre>${content}</pre>`; 
            } else { 
                card.innerHTML = `<h2>${modelName}</h2><div class="content-body">${marked.parse(content)}</div>`; 
            } 
            resultsContainer.appendChild(card); 
        }

        function displayPerplexityResult(messageData, rawResponse = null) {
            let content = messageData.content || '';
            const search_results = rawResponse.search_results || [];
            const citations = rawResponse.citations || [];

            if (citations.length > 0) {
                content = content.replace(/\[(\d+)\]/g, (match, number) => {
                    const index = parseInt(number, 10) - 1;
                    if (citations[index]) {
                        const url = citations[index];
                        return `<sup><a href="${url}" target="_blank" rel="noopener noreferrer" title="ä¾†æº ${number}: ${url}">[${number}]</a></sup>`;
                    }
                    return match;
                });
            }

            let citationsListHtml = '';
            if (search_results.length > 0) {
                citationsListHtml += '<div class="sources-list"><h3>ğŸ“š å¼•ç”¨ä¾†æº</h3><ol>';
                search_results.forEach((result) => {
                    const url = result.url || '#';
                    const title = result.title || url;
                    try {
                        const domain = new URL(url).hostname;
                        citationsListHtml += `<li><a href="${url}" target="_blank" rel="noopener noreferrer">${title}</a> <span class="source-domain">(${domain})</span></li>`;
                    } catch (e) {
                         citationsListHtml += `<li><a href="${url}" target="_blank" rel="noopener noreferrer">${title}</a></li>`;
                    }
                });
                citationsListHtml += '</ol></div>';
            }
            
            const card = document.createElement('div');
            card.className = 'result-card';
            const finalHtml = marked.parse(content) + citationsListHtml;
            card.innerHTML = `<h2>Perplexity Sonar Reasoning</h2><div class="content-body">${finalHtml}</div>`;
            
            resultsContainer.appendChild(card);
        }

        async function callAPI(modelName, url, options, responseHandler) { 
            try { 
                const response = await fetch(url, options); 
                if (!response.ok) { const errorData = await response.json(); const errorMessage = errorData.error?.message || JSON.stringify(errorData.error); throw new Error(`${modelName} API Error: ${errorMessage}`); } 
                const data = await response.json(); 
                return { model: modelName, content: responseHandler(data), isError: false }; 
            } catch (error) { 
                console.error(`${modelName} Error:`, error); 
                if (error instanceof TypeError && error.message.includes('fetch')) { const detailedError = `æŸ¥è©¢å¤±æ•—ï¼š${error.message}ã€‚\n\né€™é€šå¸¸æ˜¯ç¶²è·¯é€£ç·šã€ç€è¦½å™¨å®‰å…¨å•é¡Œ (CORS) æˆ–å»£å‘Šæ””æˆªå™¨å°è‡´çš„ã€‚\n\nã€è§£æ±ºæ–¹æ¡ˆã€‘:\n1. æª¢æŸ¥æ‚¨çš„ç¶²è·¯é€£ç·šã€‚\n2. æš«æ™‚åœç”¨å»£å‘Šæ””æˆªå™¨ã€‚\n3. å¦‚æœæ‚¨æ˜¯æœ¬åœ°é–‹ç™¼ï¼Œè«‹ä½¿ç”¨ Live Serverã€‚`; return { model: modelName, content: detailedError, isError: true }; } 
                return { model: modelName, content: `æŸ¥è©¢å¤±æ•—ï¼š${error.message}`, isError: true }; 
            } 
        }

        async function callChatGPT(prompt, apiKey) { return callAPI('ChatGPT 5 Nano', 'https://api.openai.com/v1/chat/completions', { method: 'POST', headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` }, body: JSON.stringify({ model: "gpt-4o", messages: [{ role: "user", content: prompt }], temperature: 0.7 }) }, (data) => data.choices[0].message.content); }
        
        async function callGemini(prompt, apiKey) { return callAPI('Gemini 2.5 Pro', 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-pro:generateContent', { method: 'POST', headers: { 'Content-Type': 'application/json', 'x-goog-api-key': apiKey }, body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] }) }, (data) => data.candidates[0].content.parts[0].text); }
        
        async function callPerplexity(prompt, apiKey) { 
            return callAPI('Perplexity Sonar Reasoning', 'https://api.perplexity.ai/chat/completions', { 
                method: 'POST', 
                headers: { 
                    'Content-Type': 'application/json', 
                    'Authorization': `Bearer ${apiKey}` 
                }, 
                body: JSON.stringify({ 
                    model: "sonar-reasoning", 
                    messages: [{ role: "user", content: prompt }] 
                }) 
            }, (data) => {
                return data;
            }); 
        }
        
        populateBooks();
        loadLastSelection();
        loadLastResults();
    });
    </script>
</body>
</html>
